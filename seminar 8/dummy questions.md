###### Что делает команда from module import *? Какие проблемы могут возникнуть при её использовании?
Она импортирует ВСЕ классы / функции / переменные из модуля. Это довольно рискованный подход,
поэтому его используют далеко не всегда -- чаще импортируют из модуля что-то конкретно нужное.
Иначе может возникнуть непредвиденный конфликт имен.

###### Какое определение функции будет использовани при возникновении конфликта имен?
Последнее.

###### В чем проблемы использования декораторов? Можно ли процесс декорирования обернуть вспять?
Если последовательно применить к функции сразу несколько декораторов, то можно запутаться.
Вообще декорированрие функции необратимо, потому что равносильно определению функции с последующим ее переопределением
типа f = decorate(f) (то есть исходная функция просто теряется). Но это можно обойти, если в декораторе завести какую-то
переменную типа foo_original и обращаться к ней, если нужна исходная функция.

###### Как порядок декорирования влияет на результат работы функции?
Если указать сверху вниз декораторы dec_1, ..., dec_N, то получится вложение:
dec_1(open) -> ... -> dep_N(open) -> f() -> dec_N(close) -> ... -> dec_1(close)

Это можно проверить простым скриптом-примером order_sample.py (см. папку этого файла).
